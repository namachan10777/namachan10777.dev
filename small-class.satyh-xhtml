@require: list
@require: option

let concat = List.fold-left (^) ` `

let make-props props =
props |> List.fold-left (fun sacc (k, v) -> (
  sacc ^ #` `# ^ k ^ `="` ^ v ^ `"`
)) ` `


let tag ?:propsopt ?:bropt ?:indentopt tinfo s sf =
  let props = Option.from [] propsopt in
  let br = Option.from true bropt in
  let indent = Option.from 2 indentopt in
  let tinfo-inner = tinfo |> deepen-indent indent in
    `<` ^ s ^ (make-props props) ^ `>` ^ (if br then break tinfo-inner else ` `)
    ^ (sf tinfo-inner)
    ^ (if br then break tinfo else ` `) ^ `</ ` ^ s ^ `>`

let document r bt =
  let tinfo = get-initial-text-info () in
    concat [
      `<?xml version="1.0" encoding="UTF-8"?>` ^ (break tinfo);
      `<!DOCTYPE html>` ^ (break tinfo);
      tag ?:[(`xmlns`, `http://www.w3.org/1999/xhtml`);(`lang`, `ja`)] tinfo `html` (fun tinfo ->
        concat [
          tag tinfo `head` (fun tinfo ->
            tag ?* ?:false tinfo `title` (fun tinfo ->
              stringify-inline tinfo r#title
            )
          );
          tag tinfo `body` (fun tinfo ->
            stringify-block tinfo bt
          );
        ]
      );
    ]

let-rec listing-item tinfo depth (Item(parent, children)) =
  let str-parent = tag ?* ?:false tinfo `li` (fun tinfo ->
    stringify-inline tinfo parent)
  in
  if List.length children > 0
  then
    concat
      [str-parent ^ (break tinfo);
      tag tinfo `ul` (fun tinfo -> 
        concat (List.map (listing-item tinfo (depth + 1)) children));
      (break tinfo);]
  else
    str-parent ^ (break tinfo)

let listing tinfo (Item(_,itmzlst)) =
  tag tinfo `ul` (fun tinfo ->
    List.map (listing-item tinfo 0) itmzlst
    |> concat)

let-block tinfo +listing item =
  listing tinfo item

let-block tinfo +p it =
  tag ?* ?:true tinfo `p` (fun tinfo -> stringify-inline tinfo it) ^ (break tinfo)
