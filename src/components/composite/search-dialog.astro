---
import { Icon } from "astro-icon/components";
---

<search-dialog>
  <dialog>
    <search>
      <search class="search-box">
        <Icon name="iconoir:search" class="search-icon" />
        <input type="text" class="text-input" />
        <button class="close-button">
          <Icon name="iconoir:xmark" class="close-icon" />
        </button>
      </search>
      <nav>
        <ul class="founds"></ul>
      </nav>
    </search>
  </dialog>
</search-dialog>

<style>
  .search-box {
    display: flex;
    flex-direction: row;
    gap: 0.5rem;
    align-items: center;
  }

  .search-icon {
    font-size: var(--font-size-2xl);
  }

  .close-icon {
    font-size: var(--font-size-2xl);
  }

  .text-input {
    height: 2rem;
  }

  .founds {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .founds :global(.found-title) {
    font-size: var(--font-size-lg);
    color: var(--fg-link);
  }

  .founds :global(.found-excerpt) {
    font-size: var(--font-size-sm);
    color: var(--fg-weak);
  }

  .founds :global(mark) {
    background-color: yellow;
  }

  dialog {
    padding: 0;
    border: none;
  }

  dialog::backdrop {
    backdrop-filter: blur(5px);
  }
</style>

<script>
  import type { SearchDialog } from "~/lib/search-dialog";
  import type { Pagefind } from "~/lib/pagefind";

  interface DebouncerOption {
    timeout?: number;
  }

  class Debouncer<T> {
    readonly #callback: (value: T) => void;
    readonly #timeoutMillis: number;

    #timeoutHandler: Timer | null = null;
    #beforeAppliedAtMillis: number = Date.now();
    #value: T | null = null;

    constructor(
      private readonly callback: (value: T) => void,
      option?: DebouncerOption,
    ) {
      this.#callback = callback;
      this.#timeoutMillis = option?.timeout ?? 500;
    }

    put(value: T) {
      this.#value = value;
      if (this.#timeoutHandler !== null) {
        clearTimeout(this.#timeoutHandler);
        this.#timeoutHandler = null;
        const now = Date.now();
        if (
          now - this.#beforeAppliedAtMillis >= this.#timeoutMillis &&
          this.#value !== null
        ) {
          this.#callback(this.#value);
          this.#beforeAppliedAtMillis = now;
        }
      }
      this.#timeoutHandler = setTimeout(() => {
        if (this.#value !== null) {
          this.#callback(this.#value);
        }
        this.#timeoutHandler = null;
        this.#beforeAppliedAtMillis = Date.now();
      }, this.#timeoutMillis);
    }
  }

  class SearchDialogElement extends HTMLElement implements SearchDialog {
    readonly #dialog: HTMLDialogElement;
    #scrollY = 0;
    readonly #debouncer: Debouncer<string>;
    readonly #textInput: HTMLInputElement;
    #pagefind: Pagefind | null = null;
    #founds: HTMLUListElement;

    constructor() {
      super();
      this.#dialog = this.querySelector("dialog")!;
      this.#textInput = this.querySelector(
        "input.text-input",
      )! as HTMLInputElement;
      this.#founds = this.querySelector("ul.founds")!;
      this.#debouncer = new Debouncer((value) => {
        this.#applyNewQueryDirectly(value);
      });
      this.#setupDialogCloseHandler();
      this.#setupInputHandler();
      (async () => {
        const pagefind = (await import(
          /* @vite-ignore */
          `${"/pagefind/pagefind.js"}`
        )) as unknown as Pagefind;
        await pagefind.init();
        this.#pagefind = pagefind;
      })();
    }

    #setupInputHandler() {
      this.#textInput.addEventListener("input", (event) => {
        const target = event.target as HTMLInputElement;
        if (this.#pagefind) {
          this.#pagefind.debouncedSearch(target.value).then(async (founds) => {
            if (founds) {
              const pages = await Promise.all(
                founds.results.map((found) => found.data()),
              );
              const elements = pages.map((page) => {
                const title = document.createElement("a");
                title.textContent = page.meta.title;
                title.href = page.url;
                title.classList.add("found-title");

                const excerpt = document.createElement("p");
                excerpt.classList.add("found-excerpt");
                excerpt.innerHTML = page.excerpt;

                const li = document.createElement("li");
                li.appendChild(title);
                li.appendChild(excerpt);
                return li;
              });
              this.#founds.replaceChildren(...elements);
            }
          });
        }
      });
    }

    #applyNewQueryDirectly(query: string) {
      console.log(query);
    }

    #setupDialogCloseHandler() {
      this.#dialog.addEventListener("click", (event) => {
        const target = event.target as HTMLElement | null;
        if (target && target.closest("search") === null) {
          this.close();
        }
      });

      this.#dialog.addEventListener("touchstart", (event) => {
        const target = event.target as HTMLElement | null;
        if (target && target.closest("search") === null) {
          this.close();
        }
      });

      this.#dialog.addEventListener("close", () => {
        this.#closeHandler();
      });

      const closeButton = this.querySelector("button.close-button")!;
      closeButton.addEventListener("click", () => {
        this.close();
      });
    }

    #closeHandler() {
      this.#textInput.value = "";
      document.body.style.position = "";
      window.scrollTo({
        top: this.#scrollY,
        behavior: "instant",
      });
      document.body.style.overflow = "";
      document.body.style.top = "";
    }

    showModal(): void {
      this.#dialog.showModal();
      this.#scrollY = window.scrollY;
      document.body.style.overflowY = "scroll";
      document.body.style.position = "fixed";
      document.body.style.top = `-${this.#scrollY}px`;
    }

    close(): void {
      this.#dialog.close();
    }
  }

  customElements.define("search-dialog", SearchDialogElement);
</script>
